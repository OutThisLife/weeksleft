/* eslint-disable no-nested-ternary */
import { OrbitControls } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { Bloom, EffectComposer, Vignette } from '@react-three/postprocessing'
import { BlendFunction } from 'postprocessing'
import * as React from 'react'
import type { InstancedMesh } from 'three'
import * as THREE from 'three'
import { lerp } from 'three/src/math/MathUtils'

const n = 9
const len = n ** 2
const r = [...Array(len).keys()]

const tmpc = new THREE.Vector4()

const state = {
  colours: Float32Array.from(r.flatMap(() => tmpc.set(1, 1, 1, 0.1).toArray())),
  positions: r.map(() => new THREE.Vector3(0, 0, 0)),
  scales: r.flatMap(() => new THREE.Vector3(1, 1, 1))
}

const Instance: React.FC = ({ children }) => {
  const ref = React.useRef<InstancedMesh>()

  const [{ active, hovered }, set] = React.useState<{
    hovered?: number
    active?: number
  }>({})

  const tmp = new THREE.Object3D()

  const f = (x: number): number => {
    const d = 1

    if (!(x % 2)) {
      return d - (x + 1) * 0.33
    }

    return d + x * 0.33
  }

  useFrame(() => {
    if (ref.current) {
      let i = 0

      for (let x = 0; x < n; x++)
        for (let y = 0; y < n; y++) {
          const id = i++

          const a = active === id
          const h = hovered === id

          state.positions[id].set(
            a ? 0 : f(x),
            -f(y),
            lerp(state.positions[id].z, a ? 0.5 : h ? 0.1 : 0, 0.1)
          )

          state.scales[id].set(lerp(state.scales[id].x, a ? 10 : 1, 0.1), 1, 1)

          if (id <= 13) {
            tmpc.set(1, h ? 0.2 : 0.41, 0.7, 1).toArray(state.colours, id * 4)
          } else {
            tmpc
              .set(0.2, 0.2, 0.2, a ? 1 : h ? 0.8 : 0.5)
              .toArray(state.colours, id * 4)
          }

          ref.current.geometry.attributes.color.needsUpdate = true

          tmp.position.copy(state.positions[id])
          tmp.scale.copy(state.scales[id])

          tmp.updateMatrix()
          ref.current.setMatrixAt(id, tmp.matrix)
        }

      ref.current.instanceMatrix.needsUpdate = true
    }
  })

  return (
    <instancedMesh
      args={[undefined, undefined, len]}
      onPointerDown={e =>
        set(st => ({
          ...st,
          active: st.active === e.instanceId ? undefined : e.instanceId
        }))
      }
      onPointerMove={e => set(st => ({ ...st, hovered: e.instanceId }))}
      onPointerOut={() => set(st => ({ ...st, hovered: undefined }))}
      position={[0, 0, 0]}
      {...{ ref }}>
      {children}
    </instancedMesh>
  )
}

const App: React.FC = () => {
  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight intensity={0.5} position={[0, 0, 20]} />

      <OrbitControls screenSpacePanning />

      <Instance>
        <boxBufferGeometry args={[0.5, 0.5, 0.5]}>
          <instancedBufferAttribute
            args={[state.colours, 4]}
            attachObject={['attributes', 'color']}
          />
        </boxBufferGeometry>
        <meshPhongMaterial vertexColors />
      </Instance>

      <EffectComposer>
        <Bloom height={200} luminanceThreshold={0.1} />
        <Vignette
          blendFunction={BlendFunction.NORMAL}
          darkness={0.5}
          offset={0.1}
        />
      </EffectComposer>
    </>
  )
}

export default App
